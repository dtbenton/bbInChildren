get_init_priors = function(L, p) {
mod_priors = c()
for (model in L) {
prior_prob = 1
for (spec in model) {
prior_prob = prior_prob*((1-p)^(1-spec))*(p^spec)
}
mod_priors = c(mod_priors, prior_prob)
}
return(mod_priors)
}
get_likelihoods = function(L, event) {
placements = event[1:length(event)-1]
outcome = event[length(event)]
likelihoods = c()
for (model in L) {
activation = 0
for (i in 1:length(placements)) {
if (placements[i]==1 & model[i]==1) {
activation = 1
}
}
likelihoods = c(likelihoods, activation==outcome)
}
return(likelihoods)
}
compute_two_posts = function(L, priors, event1, event2) {
likelihoods1 = get_likelihoods(L, event1)
likelihoods2 = get_likelihoods(L, event2)
numerators = likelihoods1*likelihoods2*priors
norm_term = sum(numerators)
return(numerators/norm_term)
}
get_blicket_probs = function(L, posts) {
blicket_probs = c()
for (i in 1:length(L[[1]])) {
prob = 0
for (j in 1:length(L)) {
prob = prob + L[[j]][i]*posts[j]
}
blicket_probs = c(blicket_probs, prob)
}
return(blicket_probs)
}
MyIntToBit = function(x, dig) {
i <- 0L
string <- numeric(dig)
while (x > 0) {
string[dig - i] <- x %% 2L
x <- x %/% 2L
i <- i + 1L
}
string
}
get_model_list = function(num_blickets) {
return(lapply(0:(2^num_blickets - 1), function(x) MyIntToBit(x, num_blickets)))
}
bayes_model_func = function(x,prob,event1,event2){
L = get_model_list(x) # x is the number of candidate causes
priors = get_init_priors(L, prob) # prob = probability that an object is a blicket
event1 = event1 #event1/event2 are lists, in which the first n elements correspond to the # of candidate causes and teh last element corresponds to
# whether the machine activates
event2 = event2
posts = compute_two_posts(L, priors, event1, event2)
blicket_probs = get_blicket_probs(L, posts)
print(blicket_probs)
}
# BBexperimental: ABC+ A+
bayes_model_func(x=3,0.5,event1=c(1,1,1,1),event2=c(1,0,0,1))
lapply(0:(2^2 - 1)
lapply(0:(2^2 - 1))
rm(list=ls())
num_blickets = 3
num_blickets = 3
p = 0.5  # or whatever prior probability you assume
L = get_model_list(num_blickets)
get_init_priors = function(L, p) {
mod_priors = c()
for (model in L) {
prior_prob = 1
for (spec in model) {
prior_prob = prior_prob*((1-p)^(1-spec))*(p^spec)
}
mod_priors = c(mod_priors, prior_prob)
}
return(mod_priors)
}
get_likelihoods = function(L, event) {
placements = event[1:length(event)-1]
outcome = event[length(event)]
likelihoods = c()
for (model in L) {
activation = 0
for (i in 1:length(placements)) {
if (placements[i]==1 & model[i]==1) {
activation = 1
}
}
likelihoods = c(likelihoods, activation==outcome)
}
return(likelihoods)
}
update_posterior = function(L, priors, event) {
likelihoods = get_likelihoods(L, event)
numerators = likelihoods*priors
norm_term = sum(numerators)
return(numerators/norm_term)
}
get_blicket_probs = function(L, posts) {
blicket_probs = c()
for (i in 1:length(L[[1]])) {
prob = 0
for (j in 1:length(L)) {
prob = prob + L[[j]][i]*posts[j]
}
blicket_probs = c(blicket_probs, prob)
}
return(blicket_probs)
}
MyIntToBit = function(x, dig) {
i <- 0L
string <- numeric(dig)
while (x > 0) {
string[dig - i] <- x %% 2L
x <- x %/% 2L
i <- i + 1L
}
string
}
get_model_list = function(num_blickets) {
return(lapply(0:(2^num_blickets - 1), function(x) MyIntToBit(x, num_blickets)))
}
num_blickets = 3
p = 0.5  # or whatever prior probability you assume
L = get_model_list(num_blickets)
# Initializing priors (probabilities before any event)
priors_init = get_init_priors(L, p)
blicket_probs_init = get_blicket_probs(L, priors_init)
# Assume we have two events
events = list(c(1, 0, 1, 0), c(0, 1, 0, 1))
priors_midway = update_posterior(L, priors_init, events[[1]])
priors_midway
blicket_probs_midway = get_blicket_probs(L, priors_midway)
blicket_probs_midway
priors_after = update_posterior(L, priors_midway, events[[2]])
blicket_probs_after = get_blicket_probs(L, priors_after)
priors_after
blicket_probs_after
print("Blicket probabilities before any events:")
print(blicket_probs_init)
print("Blicket probabilities midway through events:")
print(blicket_probs_midway)
print("Blicket probabilities after all events:")
print(blicket_probs_after)
get_model_list(3)
3 %% 2L
num_blickets = 2
p = 0.5  # or whatever prior probability you assume
L = get_model_list(num_blickets)
priors_init = get_init_priors(L, p)
blicket_probs_init = get_blicket_probs(L, priors_init)
blicket_probs_init
# Assume we have two events
events = list(c(1, 1, 1), c(1, 1, 1), c(1, 0, 1))
# Probabilities after first event (midway)
priors_midway = update_posterior(L, priors_init, events[[1]])
priors_midway
blicket_probs_midway = get_blicket_probs(L, priors_midway)
blicket_probs_midway
priors_after = update_posterior(L, priors_midway, events[[2]])
blicket_probs_after = get_blicket_probs(L, priors_after)
priors_after
blicket_probs_after
num_blickets = 2
L = get_model_list(num_blickets)
# Define the initial prior probability
p = 0.5
cat("Prior probabilities before any event:\n")
print(priors)
priors = get_init_priors(L, p)
# Print the priors before any event
cat("Prior probabilities before any event:\n")
print(priors)
event1 = c(1, 1, 1)
event2 = c(1, 1, 1)
event3 = c(1, 0, 1)
posts_after_two_events = compute_two_posts(L, priors, event1, event2)
MyIntToBit = function(x, dig) {
i <- 0L
string <- numeric(dig)
while (x > 0) {
string[dig - i] <- x %% 2L
x <- x %/% 2L
i <- i + 1L
}
string
}
get_model_list = function(num_blickets) {
return(lapply(0:(2^num_blickets - 1), function(x) MyIntToBit(x, num_blickets)))
}
get_init_priors = function(L, p) {
mod_priors = c()
for (model in L) {
prior_prob = 1
for (spec in model) {
prior_prob = prior_prob*((1-p)^(1-spec))*(p^spec)
}
mod_priors = c(mod_priors, prior_prob)
}
return(mod_priors)
}
get_likelihoods = function(L, event) {
placements = event[1:length(event)-1]
outcome = event[length(event)]
likelihoods = c()
for (model in L) {
activation = 0
for (i in 1:length(placements)) {
if (placements[i]==1 & model[i]==1) {
activation = 1
}
}
likelihoods = c(likelihoods, activation==outcome)
}
return(likelihoods)
}
compute_two_posts = function(L, priors, event1, event2) {
likelihoods1 = get_likelihoods(L, event1)
likelihoods2 = get_likelihoods(L, event2)
numerators = likelihoods1*likelihoods2*priors
norm_term = sum(numerators)
return(numerators/norm_term)
}
get_blicket_probs = function(L, posts) {
blicket_probs = c()
for (i in 1:length(L[[1]])) {
prob = 0
for (j in 1:length(L)) {
prob = prob + L[[j]][i]*posts[j]
}
blicket_probs = c(blicket_probs, prob)
}
return(blicket_probs)
}
num_blickets = 2
L = get_model_list(num_blickets)
# Define the initial prior probability
p = 0.5
# Get the initial priors
priors = get_init_priors(L, p)
cat("Prior probabilities before any event:\n")
print(priors)
event1 = c(1, 1, 1)
event2 = c(1, 1, 1)
event3 = c(1, 0, 1)
# Calculate the posterior probabilities after the first two events
posts_after_two_events = compute_two_posts(L, priors, event1, event2)
posts_after_two_events
cat("Posterior probabilities after the first two events:\n")
print(posts_after_two_events)
blicket_probs_after_two_events = get_blicket_probs(L, posts_after_two_events)
# Print individual blicket probabilities after the first two events
cat("Individual blicket probabilities after the first two events:\n")
print(blicket_probs_after_two_events)
# Now, compute the posterior probabilities after all three events. This involves taking the posterior probabilities
# from the first two events and treating them as the priors for the third event.
posts_after_three_events = compute_two_posts(L, posts_after_two_events, event1, event3)
# Print the priors after all three events
cat("Posterior probabilities after all three events:\n")
print(posts_after_three_events)
blicket_probs_after_three_events = get_blicket_probs(L, posts_after_three_events)
# Print individual blicket probabilities after all three events
cat("Individual blicket probabilities after all three events:\n")
print(blicket_probs_after_three_events)
num_blickets = 2
L = get_model_list(num_blickets)
# Define the initial prior probability
p = 0.5
# Get the initial priors
priors = get_init_priors(L, p)
cat("Prior probabilities before any event:\n")
print(priors)
blicket_probs_before_any_events = get_blicket_probs(L, priors)
# Print individual blicket probabilities before any events
cat("Individual blicket probabilities before any events:\n")
print(blicket_probs_before_any_events)
# Define three events
event1 = c(1, 1, 1)
event2 = c(1, 1, 1)
event3 = c(1, 0, 1)
# Calculate the posterior probabilities after the first two events
posts_after_two_events = compute_two_posts(L, priors, event1, event2)
# Print the priors after the first two events
cat("Posterior probabilities after the first two events:\n")
print(posts_after_two_events)
blicket_probs_after_two_events = get_blicket_probs(L, posts_after_two_events)
# Print individual blicket probabilities after the first two events
cat("Individual blicket probabilities after the first two events:\n")
print(blicket_probs_after_two_events)
posts_after_three_events = compute_two_posts(L, posts_after_two_events, event1, event3)
# Print the priors after all three events
cat("Posterior probabilities after all three events:\n")
print(posts)
# Print the priors after all three events
cat("Posterior probabilities after all three events:\n")
print(posts_after_three_events)
# Get individual blicket probabilities after all three events
blicket_probs_after_three_events = get_blicket_probs(L, posts_after_three_events)
# Print individual blicket probabilities after all three events
cat("Individual blicket probabilities after all three events:\n")
print(blicket_probs_after_three_events)
for(model in c(1,0,1)){
for(spec in model){
print(spec)
}
}
get_model_list(2)
0:(2^2 - 1)
0:(2^4 - 1)
MyIntToBit = function(x, dig) {
i <- 0L
string <- numeric(dig)
while (x > 0) {
string[dig - i] <- x %% 2L
x <- x %/% 2L
i <- i + 1L
}
string
}
get_model_list = function(num_blickets) {
return(lapply(0:(2^num_blickets - 1), function(x) MyIntToBit(x, num_blickets)))
}
get_model_list(4)
get_model_list(2)
3 %% 2L
string <- numeric(4)
string
1 %/% 2L
MyIntToBit = function(x, dig) {
i <- 0L
string <- numeric(dig)
while (x > 0) {
string[dig - i] <- x %% 2L
x <- x %/% 2L
i <- i + 1L
}
string
}
get_model_list = function(num_blickets) {
return(lapply(0:(2^num_blickets - 1), function(x) MyIntToBit(x, num_blickets)))
}
L = get_model_list(2)
mod_priors = c()
for (model in L) {
prior_prob = 1
for (spec in model) {
prior_prob = prior_prob*((1-p)^(1-spec))*(p^spec)
}
prior_prob
}
mod_priors = c()
for (model in L) {
prior_prob = 1
for (spec in model) {
prior_prob = prior_prob*((1-p)^(1-spec))*(p^spec)
}
print(prior_prob)
}
rm(list=ls())
MyIntToBit = function(x, dig) {
i <- 0L
string <- numeric(dig)
while (x > 0) {
string[dig - i] <- x %% 2L
x <- x %/% 2L
i <- i + 1L
}
string
}
get_model_list = function(num_blickets) {
return(lapply(0:(2^num_blickets - 1), function(x) MyIntToBit(x, num_blickets)))
}
L = get_model_list(2)
mod_priors = c()
for (model in L) {
prior_prob = 1
for (spec in model) {
prior_prob = prior_prob*((1-p)^(1-spec))*(p^spec)
}
print(prior_prob)
}
mod_priors = c()
for (model in L) {
prior_prob = 1
print(model)
for (spec in model) {
prior_prob = prior_prob*((1-p)^(1-spec))*(p^spec)
print(spec)
}
}
mod_priors = c()
for (model in L) {
prior_prob = 1
print(model)
for (spec in model) {
prior_prob = prior_prob*((1-0.5)^(1-spec))*(p^spec)
print(spec)
}
}
L = get_model_list(2)
mod_priors = c()
for (model in L) {
prior_prob = 1
print(model)
for (spec in model) {
prior_prob = prior_prob*((1-0.5)^(1-spec))*(p^spec)
print(spec)
}
}
p=0.5
mod_priors = c()
for (model in L) {
prior_prob = 1
print(model)
for (spec in model) {
prior_prob = prior_prob*((1-p)^(1-spec))*(p^spec)
print(spec)
}
}
1*((1-0.5)^(1-0))*(0.5^0)
L = get_model_list(2)
p=0.5
mod_priors = c()
for (model in L) {
prior_prob = 1
print(model)
for (spec in model) {
prior_prob = prior_prob*((1-p)^(1-spec))*(p^spec)
print(spec)
print(prior_prob)
}
}
